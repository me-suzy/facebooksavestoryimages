from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.common.action_chains import ActionChains
import time
import os
import requests
import re
import json
from urllib.parse import unquote, urlparse

def connect_to_existing_chrome():
    """ConecteazƒÉ la instan»õa Chrome deja deschisƒÉ cu remote debugging"""
    chrome_options = Options()
    chrome_options.add_experimental_option("debuggerAddress", "127.0.0.1:9222")

    try:
        driver = webdriver.Chrome(options=chrome_options)
        print("‚úÖ Conectat la Chrome cu succes!")
        return driver
    except Exception as e:
        print(f"‚ùå Eroare la conectare: {e}")
        return None

def get_current_profile_info(driver):
    """Extrage informa»õii despre profilul curent din story"""
    try:
        profile_info = {
            'name': None,
            'profile_url': None,
            'timestamp': time.time()
        }

        # SalveazƒÉ codul sursƒÉ pentru depanare
        try:
            with open("facebook_profile_check.html", "w", encoding="utf-8") as f:
                f.write(driver.page_source)
            print("üíæ Codul sursƒÉ al paginii curente salvat √Æn 'facebook_profile_check.html'")
        except:
            pass

        # Selector principal
        try:
            name_elements = WebDriverWait(driver, 20).until(
                EC.presence_of_all_elements_located((By.CSS_SELECTOR, "span.x1lliihq.x6ikm8r.x10wlt62.x1n2onr6.xlyipyv.xuxw1ft"))
            )
            if name_elements:
                profile_info['name'] = name_elements[0].text.strip()
                print(f"üîç Nume profil detectat: {profile_info['name']}")
        except:
            print("‚ö†Ô∏è Selectorul principal CSS nu a gƒÉsit numele.")

        # Selector alternativ bazat pe structura HTML
        if not profile_info['name']:
            try:
                name_elements_alt = WebDriverWait(driver, 10).until(
                    EC.presence_of_all_elements_located(
                        (By.XPATH, "//div[contains(@class, 'x9f619 x1ja2u2z x78zum5 x2lah0s x1n2onr6 x1nhvcw1')]//span[contains(@class, 'x1lliihq x6ikm8r x10wlt62 x1n2onr6 xlyipyv xuxw1ft')]")
                    )
                )
                if name_elements_alt:
                    profile_info['name'] = name_elements_alt[0].text.strip()
                    print(f"üîç Nume profil detectat cu selector alternativ: {profile_info['name']}")
            except:
                print("‚ö†Ô∏è Selectorul alternativ XPath nu a gƒÉsit numele.")

        # √éncearcƒÉ sƒÉ gƒÉseascƒÉ URL-ul profilului
        try:
            profile_links = driver.find_elements(By.CSS_SELECTOR, "a[href*='facebook.com/']")
            for link in profile_links:
                href = link.get_attribute('href')
                if href and ('/stories/' not in href) and ('facebook.com/' in href):
                    profile_info['profile_url'] = href
                    break
        except:
            pass

        return profile_info

    except Exception as e:
        print(f"‚ùå Eroare la extragerea informa»õiilor profilului: {e}")
        return {'name': None, 'profile_url': None, 'timestamp': time.time()}

def is_same_profile(original_profile, current_profile):
    """VerificƒÉ dacƒÉ suntem √ÆncƒÉ pe acela»ôi profil"""
    if not original_profile['name'] or not current_profile['name']:
        print("‚ö†Ô∏è Nume profil nedetectat. Nu pot verifica schimbarea profilului.")
        return False  # Oprim navigarea dacƒÉ nu putem verifica
    return original_profile['name'] == current_profile['name']

def extract_video_urls(driver):
    """Extrage URL-uri video din pagina curentƒÉ"""
    video_urls = []

    try:
        # 1. Elemente video directe
        video_elements = driver.find_elements(By.TAG_NAME, "video")
        for video in video_elements:
            try:
                video_url = video.get_attribute("src")
                if video_url and video_url not in video_urls:
                    video_urls.append(video_url)
                    print(f"‚úÖ Video direct: {video_url[:80]}...")
            except:
                pass

        # 2. AnalizƒÉ page source
        page_source = driver.page_source
        patterns = [
            r'src="(https://[^"]*\.mp4[^"]*)"',
            r'video_url":"([^"]+)"',
            r'hd_src":"([^"]+)"',
            r'sd_src":"([^"]+)"',
            r'contentUrl":"([^"]+)"',
        ]

        for pattern in patterns:
            matches = re.findall(pattern, page_source)
            for match in matches:
                clean_url = unquote(match.replace('\\u0025', '%').replace('\\/', '/'))
                if clean_url not in video_urls and any(ext in clean_url for ext in ['.mp4', 'video']):
                    video_urls.append(clean_url)
                    print(f"‚úÖ URL din source: {clean_url[:80]}...")

        # 3. JavaScript extraction
        try:
            js_script = """
            var videos = document.querySelectorAll('video');
            var urls = [];
            for (var i = 0; i < videos.length; i++) {
                if (videos[i].src) urls.push(videos[i].src);
            }
            return urls;
            """
            js_urls = driver.execute_script(js_script)
            for url in js_urls:
                if url and url not in video_urls:
                    video_urls.append(url)
                    print(f"‚úÖ URL din JS: {url[:80]}...")
        except:
            pass

        # 4. VerificƒÉ iframe-urile
        try:
            iframes = driver.find_elements(By.TAG_NAME, "iframe")
            for iframe in iframes:
                try:
                    driver.switch_to.frame(iframe)
                    iframe_videos = driver.find_elements(By.TAG_NAME, "video")
                    for video in iframe_videos:
                        try:
                            video_url = video.get_attribute("src")
                            if video_url and video_url not in video_urls:
                                video_urls.append(video_url)
                                print(f"‚úÖ Video din iframe: {video_url[:80]}...")
                        except:
                            pass
                    driver.switch_to.default_content()
                except:
                    driver.switch_to.default_content()
                    continue
        except:
            pass

    except Exception as e:
        print(f"‚ùå Eroare la extragerea video-urilor: {e}")

    return list(set(video_urls))

def download_video(url, folder_path, index):
    """DescarcƒÉ un videoclip de la URL-ul dat"""
    try:
        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            'Referer': 'https://www.facebook.com/',
            'Accept': 'video/*,*/*;q=0.8'
        }

        print(f"   ‚¨áÔ∏è Descarc videoclipul {index}...")

        response = requests.get(url, headers=headers, stream=True, timeout=30)

        if response.status_code == 200:
            filename = f"story_video_{index}.mp4"
            filepath = os.path.join(folder_path, filename)

            with open(filepath, 'wb') as f:
                for chunk in response.iter_content(chunk_size=8192):
                    if chunk:
                        f.write(chunk)

            if os.path.exists(filepath) and os.path.getsize(filepath) > 0:
                print(f"   ‚úÖ Videoclip {index} descƒÉrcat: {filename} ({os.path.getsize(filepath)} bytes)")
                return True

        print(f"   ‚ùå Eroare la descƒÉrcarea videoclipului {index}")
        return False

    except Exception as e:
        print(f"   ‚ùå Eroare la descƒÉrcare: {e}")
        return False

def navigate_to_next_story(driver):
    """√éncearcƒÉ sƒÉ navigheze la urmƒÉtorul story"""
    try:
        next_button = WebDriverWait(driver, 5).until(
            EC.element_to_be_clickable((By.XPATH, "//svg[contains(@class, 'x14rh7hd') and contains(@class, 'x1lliihq')]//path[contains(@d, 'M9.209')]"))
        )
        ActionChains(driver).move_to_element(next_button).click().perform()
        print("‚úÖ Navigat cu butonul 'Next'")
        time.sleep(2)
        return True
    except:
        try:
            body = driver.find_element(By.TAG_NAME, 'body')
            body.send_keys(Keys.ARROW_RIGHT)
            print("‚úÖ Navigat cu sƒÉgeata dreapta")
            time.sleep(2)
            return True
        except:
            print("‚ùå Nu s-a putut naviga mai departe")
            return False

def save_profile_info(profile_info, filename="profiles_data.json"):
    """SalveazƒÉ informa»õiile profilului √Æn fi»ôier JSON"""
    try:
        data = []
        if os.path.exists(filename):
            with open(filename, 'r', encoding='utf-8') as f:
                data = json.load(f)

        data.append(profile_info)

        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(data, f, indent=2, ensure_ascii=False)

        print(f"üíæ Informa»õii profil salvate √Æn {filename}")
    except Exception as e:
        print(f"‚ùå Eroare la salvarea datelor profilului: {e}")

def main():
    story_url = "https://www.facebook.com/stories/2285180934855389/UzpfSVNDOjc4NjM2MjEyNzE5MjgwMA==/?bucket_count=9&source=story_tray"

    print("=" * 70)
    print("üé¨ FACEBOOK STORY DOWNLOADER")
    print("üì± Cu detectare automatƒÉ a schimbƒÉrii profilului")
    print("=" * 70)

    # ConecteazƒÉ la Chrome
    driver = connect_to_existing_chrome()
    if not driver:
        return

    try:
        # AcceseazƒÉ URL-ul story-ului
        print(f"üåê Accesez: {story_url}")
        driver.get(story_url)
        time.sleep(5)

        # Click pe ‚ÄûClick to view story‚Äù
        try:
            story_button = WebDriverWait(driver, 10).until(
                EC.element_to_be_clickable((By.XPATH, "//div[contains(@class, 'x1i10hfl') and @role='button']//span[contains(text(), 'Click to view story')]"))
            )
            ActionChains(driver).move_to_element(story_button).click().perform()
            print("‚úÖ Am dat click pe 'Click to view story'...")
            time.sleep(3)
        except Exception as e:
            print(f"‚ùå Eroare la deschiderea story-ului: {e}")

        # Ob»õine informa»õiile profilului ini»õial
        initial_profile = get_current_profile_info(driver)
        if not initial_profile['name']:
            print("‚ùå Nu s-a detectat numele profilului ini»õial. VerificƒÉ 'facebook_profile_check.html' pentru depanare.")
            return
        print(f"üë§ Profil ini»õial detectat: {initial_profile['name']}")
        save_profile_info(initial_profile)

        # Parcurge story-urile
        all_video_urls = []
        max_frames = 10

        for frame in range(max_frames):
            print(f"\nüìπ CADRU {frame + 1}/{max_frames}")
            print("=" * 50)

            # VerificƒÉ dacƒÉ suntem √ÆncƒÉ pe acela»ôi profil
            current_profile = get_current_profile_info(driver)
            if not is_same_profile(initial_profile, current_profile):
                print(f"üö® S-a detectat schimbare de profil!")
                print(f"   De la: {initial_profile['name']}")
                print(f"   La: {current_profile['name'] or 'Nedetectat'}")
                print("‚èπÔ∏è Oprire pentru a evita descƒÉrcarea de la alte profile")
                break

            # Extrage URL-uri video
            frame_urls = extract_video_urls(driver)

            # AdaugƒÉ URL-uri noi
            new_urls = [url for url in frame_urls if url not in all_video_urls]
            all_video_urls.extend(new_urls)

            for url in new_urls:
                print(f"üéØ Video gƒÉsit: {url[:100]}...")

            if not new_urls:
                print("‚ÑπÔ∏è Nu s-au gƒÉsit video-uri noi √Æn acest cadru")

            # SalveazƒÉ screenshot »ôi page source pentru referin»õƒÉ
            try:
                driver.save_screenshot(f"story_frame_{frame + 1}.png")
                print(f"üì∏ Screenshot salvat: story_frame_{frame + 1}.png")
                with open(f"facebook_story_source_frame_{frame + 1}.html", "w", encoding="utf-8") as f:
                    f.write(driver.page_source)
                print(f"üíæ Codul sursƒÉ al cadrului {frame + 1} salvat √Æn 'facebook_story_source_frame_{frame + 1}.html'")
            except:
                pass

            # NavigheazƒÉ la urmƒÉtorul cadru (dacƒÉ nu suntem la ultimul)
            if frame < max_frames - 1:
                if not navigate_to_next_story(driver):
                    print("‚èπÔ∏è Nu se poate naviga mai departe")
                    break
            else:
                print("‚èπÔ∏è Am ajuns la limita maximƒÉ de cadre")

        # DescarcƒÉ video-urile gƒÉsite
        if all_video_urls:
            print(f"\nüéâ TOTAL: {len(all_video_urls)} VIDEO-URI GƒÇSITE!")

            download_folder = "facebook_story_videos"
            os.makedirs(download_folder, exist_ok=True)

            success_count = 0
            print(f"\nüì• DESCƒÇRCARE √éN '{download_folder}'...")

            for i, url in enumerate(all_video_urls, 1):
                print(f"\nüîó VIDEO {i}/{len(all_video_urls)}")
                if download_video(url, download_folder, i):
                    success_count += 1
                time.sleep(1)

            print(f"\nüéä REZULTAT: {success_count}/{len(all_video_urls)} VIDEO-URI DESCƒÇRCATE!")
        else:
            print("\n‚ùå NU S-AU GƒÇSIT VIDEO-URI")
            print("\nüí° Sfaturi:")
            print("1. VerificƒÉ screenshot-urile salvate")
            print("2. Folose»ôte Developer Tools (F12) ‚Üí Network tab")
            print("3. FiltreazƒÉ dupƒÉ 'mp4' pentru a gƒÉsi manual URL-uri")

    except Exception as e:
        print(f"‚ùå EROARE: {e}")
        import traceback
        traceback.print_exc()

    finally:
        print("\n‚úÖ Browserul rƒÉm√¢ne deschis")
        print("‚ú® Proces terminat!")

if __name__ == "__main__":
    main()